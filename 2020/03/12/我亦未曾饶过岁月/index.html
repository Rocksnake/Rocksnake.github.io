<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Rokosnake">





<title>我亦未曾饶过岁月 | RokoBasilisk&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="RokoBasilisk's Blog" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">RokoのBasilisk&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">RokoのBasilisk&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">我亦未曾饶过岁月</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Rokosnake</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 12, 2020&nbsp;&nbsp;13:50:37</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Feedback/">Feedback</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>岁月不饶人，我亦未曾绕过岁月，总结反思，重新来过。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后端开发面试总结</span><br></pre></td></tr></table></figure>

<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>从效率方面考虑，数组的检索效率较好，但是插入和删除效率低下；对于链表，插入和删除的效率较好，但是检索的效率低下，然而 HashMap 合理的继承了上述两位的所有优点，意味着完美。</p>
<p>针对哈希函数的构造</p>
<ol>
<li>直接定址法</li>
<li>平方取中法</li>
<li>除数余数法</li>
</ol>
<p>为几种主要的方法，具体不展开论述，对于 HashMap 神奇存储展示拙见</p>
<blockquote>
<p>HashMap部分源码分析</p>
<ul>
<li>感触</li>
</ul>
</blockquote>
<p> HashMap 的数据是存储在 Table 数组中的，是一个 Entry 数组，二维处理的话，纵观为数组，横向为链表，每当建立一个 HashMap 的时候，就初始化一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<p>【解释】transient关键字，为了使其修饰的对象不参与序列化<br>【实质】此 table 对象无法持久化</p>
<center><img src="https://img-blog.csdnimg.cn/20200110180103273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jva29CYXNpbGlzaw==,size_16,color_FFFFFF,t_70" /></center>

<p>【总结】对于HashMap的工作原理的简要阐述（可作为面试参考回答）</p>
<p>HashMap类有一个叫做Entry的内部类。这个Entry类包含了key-value作为实例变量。 每当往hashmap        里面存放key-value对的时候，都会为它们实例化一个Entry对象，这个Entry对象就会存储在前面提到    的Entry数组table中。Entry具体存在table的那个位置是 根据key的hashcode()方法计算出来的hash值    （来决定）。</p>
<ul>
<li>定义数组中的链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; <span class="comment">//Entry数组中的链表</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取 Entry ，判断方法为【如果 key==null ，直接取数组的第一个元素，如果不是，先计算出 key 的 hashcode 找到下标，再判断是否相等，如果相等，则返回对应的 entry ，如果不相等，则返回 null 】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩容</li>
</ul>
<p>其本质是先新创建一个2倍于原来长度的 table 数组，通过重新遍历将旧的 table 中的数据复制 到新的 table 中，在新的 table 中，索引 hash 值重新计算，并且更新扩容后的阈值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line"><span class="comment">// 将table表的长度增加到之前的两倍</span></span><br><span class="line">resize(<span class="number">2</span> * table.length);</span><br><span class="line"><span class="comment">// 重新计算哈希值</span></span><br><span class="line">hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 从新计算新增元素在扩容后的table中应该存放的index</span></span><br><span class="line">bucketIndex = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>
<p>其中 resize 起到了创建一个新的 table 数组的作用</p>
<p>针对HashMap的数据存储无序性及其他特性</p>
<ul>
<li>附上一个较为完善的解析：<a href="https://www.jianshu.com/p/dde9b12343c1" target="_blank" rel="noopener">https://www.jianshu.com/p/dde9b12343c1</a></li>
</ul>
<h1 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h1><blockquote>
<ul>
<li>与 equals 的协调合作</li>
</ul>
</blockquote>
<p>hashcode 和 equals 通常是同时出现用来获取值的【在 HashMap 中使用 hashcode() 和 equals() 方法确定键值对的索引】</p>
<p><strong>用法：</strong><br>初步了解了HashMap的工作原理，在此基础上，如果要在 HashMap 中新增加元素的时候保证不重复，只用 equals 显然不如结合 hashcode方便，可以直接利用此方法将新的数据存储而不进行任何比较，这也就是查找效率高的本质，降低了比较次数。</p>
<p><strong>注意点：</strong><br>在Java中相等（相同）的对象必须具有相等的哈希码（或者散列码），但是如果两个对象的hashcode相同，它们并不一定相同。没有正确使用的时候会导致相同 hash 值的结果。</p>
<blockquote>
<ul>
<li>方法详解</li>
</ul>
</blockquote>
<p>先看 hashcode 的定义<code>public native int  hashcode();</code> – 证明 hashcode 是一个本地方法【前提是原生的方法而非经过自定义覆盖过的】</p>
<p>hashcode() 方法给对象返回一个 hash code 值，性质有以下几点：</p>
<ol>
<li>在一个Java应用执行期间，如果一个对象提供给 equals() 做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法返回的 integer 必须相同；</li>
<li>如果两个对象依 equals() 方法判断是相等的，分别调用 hashcode() 方法产生的值必须相同；</li>
<li>并不要求依 equals() 方法判断不相等的两个对象，分别调用各自的 hashCode() 方法必须产生不同的 integer 值。然而，对于不同的对象产生不同的integer结果，有可能会提高 hash table 的性能。</li>
</ol>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>我们知道 HashMap 的存储是无序的，那么为了有顺序存储键值对，就需要引入LinedHashMap。<del>【当然检验此句话可以尝试分别输出 HashMap 中存储的值和 LinkedHashMap 中的值】</del> </p>
<p>同样的在 Map 旗下，而且 LinkedHashMap 继承了 HashMap ，在定义的时候稍微变动类名就OK：<code>Map&lt;String, String&gt; = new HashMap&lt;&gt;();</code><br><code>Map&lt;String, String&gt; = new LinkedHashMap&lt;&gt;();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以在用法上，LinkedHashMap 和 HashMap 的用法基本一致，通过 put 和 get 的方法进行 key-value 的存储和读取。</p>
<blockquote>
<ul>
<li>区别点</li>
</ul>
</blockquote>
<p>LinkedHashMap 的有序性到底体现在什么地方？</p>
<p>其本质为 HashMap + 双向链表的组合，即通过 HashMap 的构造函数初始化 Entry 数组【图左】，然后通过LinkedHashMap 自身的 init  的初始化方法初始化了一个只有头节点的双向链表【图右】。</p>
<center><img src="https://img-blog.csdnimg.cn/20200111114222993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jva29CYXNpbGlzaw==,size_16,color_FFFFFF,t_70" /></center>

<p>有了双向链表的存在，那么在进行 put /扩容等操作时就需要考虑到双向链表的事。</p>
<ol>
<li>在 put 元素时，不但要把它加入到HashMap中去，还要加入到双向链表中；【记住一点：header 并不能存储数据】</li>
<li>扩容时，数据的再散列和HashMap是不一样。</li>
</ol>
<p>① HashMap 是先遍历旧 table ，再遍历旧 table 中每个元素的单向链表，取得 Entry 以后，重新计算 hash 值，然后存放到新 table 的对应位置；</p>
<p>② LinkedHashMap 是遍历的双向链表，取得每一个 Entry ，然后重新计算hash值并且存放到新 table 的对应位置。</p>
<p>附上一个较为详细的解释：<a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">https://www.jianshu.com/p/8f4f58b4b8ab</a></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>ArrayList 是可以动态增长和缩减的索引序列，它是基于数组实现的List类</p>
<p>ArrayList 的应用在于其的可变长性，本质是类对象内部定义了 capacity 属性，封装了一个动态再分配的 Object[ ] 数组，当数组的元素数量增加时，属性的值会自动增加。</p>
<p>如果想ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capcacity，可以减少增加重分配的次数提高性能 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment"> * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment"> * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            <span class="comment">//DEFAULT_CAPACITY;//这里的值为10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ArrayList 和 vector 的区别</p>
<blockquote>
<p>线程</p>
</blockquote>
<p>ArrayList 线程是不安全的, vector 的线程是安全的<br>当多线程访问一个 ArrayList 时,需要手动保持同步性</p>
</blockquote>
<blockquote>
<p>ArrayList 底层实现</p>
</blockquote>
<p>底层的数据结构就是数组，本质是 elementData，数组元素类型为Object类型，即可以存放所有类型数据【包括 null 】，所有的操作都是基于数组的。</p>
<p>ArrayList 继承了 AbstractList，AbstractList 继承了 AbstractCollection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//将扩充前的elementData大小给oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//newCapacity就是1.5倍的oldCapacity，因为向右移1位代表除以2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *这句话就是适应elementData空数组的时候，length=0</span></span><br><span class="line"><span class="comment">    *那么oldCapacity=0,newCapacity=0,所以这个判断成立</span></span><br><span class="line"><span class="comment">    *在这里就是真正的初始化elementData的大小了，前面的工作都是准备工作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     	newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//如果newCapacity超过了最大的容量的限制，就调用hugeCapacity，也就是能给的最大值给newCapacity</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">//新的容量大小已经确定好了，就copy数组，改变容量大小</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>grow() 方法是 ArrayList 的核心，该方法保障了<strong>变长</strong>特性。</p>
<p>附上一个底层方法个详解：<a href="https://blog.csdn.net/weixin_42036647/article/details/100709820" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42036647/article/details/100709820</a></p>
<blockquote>
<p>ArrayList 和数组的区别</p>
</blockquote>
<p><strong>数组</strong></p>
<p>优点：在内存中的存储时连续的，索引速度快，赋值和修改也较为方便</p>
<p>缺点：数组中插入元素比较繁琐，而且在定义时需要指定元素类型和数组长度</p>
<p><strong>ArrayList</strong></p>
<p>优点：解决了数组的缺点</p>
<p>缺点：在插入元素时，可以插入任意元素，都被处理为 Object 类，但是不保证数据安全，在数据利用的时候会报类型不匹配的错误</p>
<p>从时间复杂度的角度分析 ArrayList：<a href="https://blog.csdn.net/weixin_33939380/article/details/87975097" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33939380/article/details/87975097</a></p>
<h1 id="是如何实现的"><a href="#是如何实现的" class="headerlink" title="+= 是如何实现的"></a>+= 是如何实现的</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C/C++ code</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span> <span class="title">operator</span>+=(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">rhs</span>) </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> + rhs;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以对于 += 运算符，在使用过程中不会申请新的内存。</p>
<p><strong>由于运算符优先级不同，i = i + 1 的运算速度要低于 i += 1</strong><br>【优先级标准：优先级从上到下依次递减，最上面具有最高的优先级，逗号操作符具有最低的优先级。表达式的结合次序取决于表达式中各种运算符的优先级。优先级高的运算符先结合，优先级低的运算符后结合，同一行中的运算符的优先级相同。】</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在 Java 中字符串 String 是不可改变的，通过操作运算符改变后返回的是新对象，并不能将原有字符串改变</p>
<p><strong>原因：</strong></p>
<p>1)字符串变量是存放栈内存中的，而其所对应的字符串是存放在堆内存中的。</p>
<p>2)某个字符串变量一旦赋值，实际上就是在栈内存中的这个字符串变量通过内存地址指向到堆内存中的某个字符串。</p>
<p>3)而如果这个字符串变量所对应的字符串发生改变，在堆内存中就会新款开辟一块空间出来存放这新字符串，并使得原先的内存地址指向发生改变</p>
<p>对于之前的字符串，如果不再有其他字符串变量所指向，那么将会变成垃圾，交由 Java 中的 GC 机制进行处理。</p>
<p>【注意：无论对字符串变量进行重新赋值、截取、追加等操作其实改变的都不是字符串本身，而是指向该字符串的内存地址。】</p>
<blockquote>
<p>字符串 string 转 Int</p>
</blockquote>
<p>在 Java 中 Integer 类型下有名为 parseInt() 的方法，专门用于将字符串参数作为有符号的十进制整数进行解析【如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。】</p>
<p>实现 parseInt() 方法：</p>
<ol>
<li>使用 map 字典的形式存储从 0~9 十位数字分别对应的字母，进行字符串的切割组合</li>
<li>直接进行每一位字符的转换组合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (index &lt;= num.length() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = num.charAt(index);</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">57</span> &amp;&amp; n &gt;= <span class="number">48</span>) &#123;</span><br><span class="line">			result *= <span class="number">10</span>;</span><br><span class="line">			result += n - <span class="number">48</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			System.err.println(<span class="string">"args is not a interger"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">		result = -result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Rokosnake</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>How to thought, there is what kind of life.</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"># 面试总结</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/03/14/10%E4%BA%BF%E6%95%B0%E6%8D%AE%E6%89%BE%E7%9B%AE%E6%A0%87%EF%BC%8C%E4%BC%97%E9%87%8C%E5%AF%BB%E4%BB%96%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/">10亿数据找目标，众里寻他之红黑树</a>
            
            
            <a class="next" rel="next" href="/2020/03/12/GC-in-HotSpot-JVM/">GC in HotSpot JVM</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Rokosnake | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
    
</footer>

    </div>
</body>
</html>
